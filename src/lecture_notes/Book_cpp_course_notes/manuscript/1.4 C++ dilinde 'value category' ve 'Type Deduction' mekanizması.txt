> 'value category' : 
	>> C dilinde ifadeler(expressions) ya 'L-Value Expression' ya da 'R-Value Expression' olabilir. Üçüncü bir kategori türü
	yoktur. Bir ifadenin;
		>>> 'L-Value Expression' olması : bir nesneye karşılık gelmesi, bellekte bir yeri olması gibi özellikleri barındırır.
		>>> 'R-Value Expression' olması : doğrudan bellek alanında bir karşılığının olmaması anlamına geliyor. Yani o ifade,
		bellek alanında özdeşleşmemiştir.

	>> Legacy C++ döneminde de yukarıdaki değer kategorileri mevcut iken, Modern C++ ile değer kategorileri üç kısma
	ayrılmışlardır. Bunlar; 'L-Value Expression', 'PR-Value Expression' ve 'X-Value Expression'.

	>> NOT : 'non-const' SOL TARAF REFERANSLARINA, SAĞ TARAF DEĞER KATEGORİSİ İLE DEĞER VEREMEYİZ.

	>> 'call-by-value' döndüren fonksiyonların geri dönüş değeri de 'PR-value Expression' kapsamına girmektedir.
	'L-Value Referance' bağlanamazlar.

> C++ dilinde 'Type Deduction' mekanizması;
	>> Derleme zamanına ilişkin bir mekanizmadır. Programın çalışma zamanı ile bir ilgisi yoktur.
	
	>> Derleyici, koda bakarak bir tür çıkarımında bulunuyor. Değişkenlerin türünü çıkartırken, fonksiyonların geri dönüş
	değerlerinin türünü çıkartırken, fonksiyonların aldığı parametlerin türlerini çıkartırken, fonksiyon şablonlarında ve
	sınıf şablonlarında bu mekanizma kullanılmaktadır.
	
	>> 'auto' ve 'decltype' anahtar sözcükleri, yani 'specifiers' ları, kullanılır.
		>>> 'auto' anahtar sözcüğü C dilindeki 'auto' anahtar sözcüğü ile bir alakası yoktur. C++11 ile bu anahtar sözcük
		bambaşka bir anlam kazanmıştır ve içerisinde birbirinden farklı üç adet kural seti barındırır. Bu kural setleri,
			>>>> Sadece 'auto' anahtar sözcüğü kullanılması, yani "auto x = init_expression;": İfadenin türü neyse, o türden
			bir çıkarım yapılır.
				* Örnek 1,
					// Some code here...
					
					int foo(int, int);
					
					int main()
					{
						auto x = 100; // 'x' is a 'int'.
						
						double dval = 3.4;
						auto d = dval; // 'd' is a 'double'
						
						// İlk değer veren ifade olarak bir dizi ismi kullanıldığında, 'array-decay' mekanizması devreye
						// girer (dizinin 'const' bir dizi olması kuralı değiştirmez):
						int a[4]{1, 2, 3, 4}; // Burada 'a' dizisinin türü int[4]. Çünkü daha bu mekanizma devreye girmedi.
						
						auto xx = a;
						// 'array-decay' mekanizması ile dizi ismi, ilk elemanının adresine döner. (int[4] => &a[0])
						// Sonrasında da bu adrese bakılarak tür çıkarımı yapılır. 'xx' is a 'int*'.
						
						// İlk değer veren ifade olarak 'const' bir dizi ismi kullanıldığında, 'array-decay' mekanizması
						// devreye girer:
						const int aa[]{1, 2, 3, 4};
						// Burada 'aa' dizisinin türü const int[4]. Çünkü daha bu mekanizma devreye girmedi.
						
						auto typeAA = aa;
						// 'array-decay' mekanizması ile dizi ismi ilk elemanının adresine döner. (const int[4] => &a[0]).
						// Ki bu durumda bu adresin türü 'const int*'. Sonrasında da bu adrese bakılarak tür çıkarımı
						// yapılır. 'x' is a 'const int*'. Çünkü göstericinin kendisi 'const' değil.
						cout << "Value : " << std::is_same<decltype(typeAA), const int*>() << "\n"; // Value: 1
    					cout << "Value : " << std::is_same<decltype(typeAA), int*>() << "\n"; // Value: 0
						
						// İlk değer veren ifade olarak 'const' bir nesne kullanıldığında, 'const' özelliği düşüyor.
						const int xxx = 1000;
						auto y = xxx; // 'y' is a 'int'. 
						
						// İlk değer veren ifade olarak 'reference' bir nesne kullanıldığında, 'reference' özelliği düşüyor.
						int ival = 10;
						int& rIval = ival;
						
						auto xxxx = rIVal; // 'xxxx' is a 'int'.
						
						// İlk değer veren ifade olarak 'const-reference' bir nesne kullanıldığında, 'const-reference'
						// özelliği düşüyor.
						int ivalTwo = 10;
						int& rIvalTwo = ivalTwo;
						auto xxxxx = rIValTwo; // 'xxxxx' is a 'int'.
						
						// İlk değer veren ifade olarak bir fonksiyon ismi kullanıldığında, 'function-to-pointer' mekanizması
						// devreye girer. Bu durumda çıkarılan tür 'function-pointer' olacak.
						auto x = foo; // 'function-to-pointer conversion' happens. 'x' is a 'int (*)(int, int)'.
					}	
			
			>>>> 'auto' anahtar sözcüğü ile birlikte '&' deklaratörünün kullanılması, yani "auto& xx = init_expression":
			İfade olan türe referanstır. 'L-Value Reference' olma zorunluluğu vardır. 
				* Örnek 1,
					// Some code here...
					
					int foo(int);
					
					int main()
					{
						auto& r = 'init_expression';
						// Burada 'r' nin 'L-Value Referance' olması zorunlu.
						// Yani ya bir sentaks hatası meydana gelecek ya da 'auto' yerine bir tür çıkarımı yapılacak.
						
						// İlk değer veren ifade olarak 'R-Value Expression' kullanılması.
						auto& r = 20;
						// Burada 'auto' yerine 'int' gelecektir. Çünkü '20' rakamının türü 'int'. 'r' ise 'int&' olacaktı.
						// Bu durumda, 'L-Value Referance' türlere 'R-Value Expression' bağlanamayacağı için, sentaks hatası
						// olacaktır.
								
						// İlk değer veren ifade olarak 'L-Value Expression' kullanılması.
						int x = 10;
						auto& rx = x;
						// 'init_expression' yerine 'L-Value Expression' gelmiştir. 'x' in türü 'int' olduğu için 'rx' de
						// 'int&' türünden olacaktır. Bu durumda, 'L-Value Reference' türlere 'L-Value Expression'
						// bağlanabileceği için sentaks hatası olmayacaktır. Aslında şuna eşit olacak => "int& rx = x;".
											 
						// İlk değer veren ifade olarak 'const' bir 'L-Value Expression' kullanılması.					 
						const int y = 100;
						auto &ry = y;
						// Eğer 'const' özelliği kaybolsaydı, tür çıkarımı 'int' e göre yapılacaktı. Yani 'auto' yerine
						// 'int' gelecek, 'ry' nin türü ise 'int&' olacaktı. Fakat 'non-const' bir referans, 'const' bir
						// nesneye bağlanamayağı için bu durum da sentaks hatasına yol açacaktı. Dolayısıyla böyle bir
						// senaryoda yukarıdaki nesnenin 'const' özelliği düşmüyor. Tür çıkarımı 'const int' şeklinde
						// yapılıyor. 'ry' nin türü de 'const int&' oluyor.
						// Aslında şuna eşit olacak => "const int& ry = y".
						
						// İlk değer veren ifade olarak bir dizi ismi kullanıldığında, 'array-decay' mekanizması devreye
						// girmez. Dolayısıyla, bizim referansımız bir diziye referans olmuş olur.
						int a[] = {10, 20, 30, 40};
						auto& ra = a; // Bizim referansımız artık diziye referans. 
						// Eğer 'array-decay' mekanizması devreye girseydi, şu şekilde olacaktı => "auto& ra = &a[0];". 
						// Fakat bu durumda sentaks hatası oluşacaktı. Çünkü 'address' operatörü ile elde edilen deyimler
						// 'R-Value Expression' kategorisindedir. 'L-Value Referance' lara da 'R-Value Expression' bağlanması
						// sentaks hatasıdır. Uzun lafın kısası, aslında, şuna eşit olacak => "int (&ra)[4] = a".
						// Yani 'ra' demek 'a' demektir.
						
						// İlk değer veren ifade olarak 'string literal' kullanılsaydı eğer, yine diziye referans olacaktı.
						auto& rsl = "emre";
						// Burada "emre" 'string literal' inin türü 'const char[5]' şeklinde. 'auto' kelimesinin karşılığı
						// da 'const char[5]'. Çıkarım yapılan bu türe referans ise 'const char(&rsl)[5]' şeklinde.
						// Dolayısıyla yukarıdaki 'expression' şuna eşit olacaktı => " const char(&rsl)[5] = "emre"; ".
						
						// İlk değer veren ifade olarak fonksiyon ismi kullanılırsa, referansımız bir 'function reference'
						// olur.
						auto& rFunc = foo;
						// Dolayısıyla şuna eşit olacaktır => "int (&rFunc)(int) = foo";
					}
			
			>>>> 'auto' anahtar sözcüğü ile birlikte '&&' deklaratörünün kullanılması, yani "auto&& xx = init_expression":
			Bu durumda referansımız 'R-Value Referance' değil, ileride işlenecek olan 'forwarding Referance' şeklinde.
		
		>>> 'decltype' : Genellikle 'generic programming' tarafında kullanılır. 'decltype' kelimesinden hemen sonra '()'
		gelmek zorunda. Bu parantez çiftinin içerisine yazılacak 'expression' lara göre derleyici tür çıkarımında bulunuyor.
		Çıkarımda bulunan bu türü, tür gereken her yerde kullanabiliriz. Örneğin, değişken tanımlamalarında, fonksiyon
		tanımlamalarında vs.
			* Örnek 1,
				// Some code here...
				
				int g = 100;
				
				decltype(g) funcDecltype(decltype(g) funcParam);
				
				decltype(g) anotherVar;
				
				int main()
				{
					decltype(g) xx;
				}
		
		Burada da iki ayrı kural seti bulunmaktadır.
			>>>> 'decltype' parantezi içerisinde bir isim kullanılmasına("decltype(x)", "decltype(x.y)", "decltype(ptr->y)"
				vs.) dair kural seti:
				>>>>> Parantez içerisindeki ismin türü ne ise, o türden bir çıkarım yapılıyor.
				Örnek 1,
					// Some code here...
					
					int g = 100;
					
					const int cg = 200;
					
					int main()
					{
						decltype(g) dx; // int xx;
						
						// Parantez içerisindeki isim 'const' türden ise 'const' özelliği düşmüyor.
						decltype(cg) dcx;
						// "const int dcx;" ile eş değer. Fakat C++ dilinde 'const' nesnelere ilk değer vermek zorunlu
						// olduğundan, sentaks hatası oluşacak.
						// decltype(cg) dcx = 101; 
						
						// Parantez içerisindeki isim 'reference' türden ise 'reference' özelliği düşmüyor.
						int& rg = g;
						decltype(rg) drg;
						// "int& drg;" ile eş değer. Fakat C++ dilinde 'reference' nesnelere ilk değer vermek zorunlu
						// olduğundan, sentaks hatası oluşacak.
						// decltype(rg) drg = g; 
						
						// Parantez içerisindeki isim 'const' 'reference' türden ise 'const' 'reference' özelliği düşmüyor.
						
						// Parantez içerisinde dizi ismi kullanıldığında 'array-decay' mekanizması devreye girmiyor. 
						int a[4] = {1, 2, 3, 4}; // 'a' dizisinin türü 'int[4]'.
						decltype(a) b; // 'b' dizisinin türü de 'int[4]' olacak. 
						
						const char str[] = "alican"; // 'str' dizisinin türü 'const char[7]';
						decltype(str) var;
						// 'var' dizisinün türü de 'const char[7]' olacaktır. Fakat ilk değer vermediğimiz için bu çağrı
						// sentaks hatası olacak. Çünkü 'const' türden değişkenlere ilk değer vermeliyiz.
						// decltype(str) ss = "emre"; // Aslında şuna eşit olacaktı => " const char[7] ss = "emre"; ".
					}
			
			>>>> 'decltype' parantezi içerisinde isim formunda olmayan("decltype(10)", "decltype(*ptr)", "decltype(x + 5)",
			"decltype((x))" vs.) bir ifade kullanılmasına dair kural seti: İlgili ifadenin 'value category' sine göre bir tür
			çıkarımında bulunulur. Aşağıdaki tabloyu inceleyiniz:
			'decltype' parantezi içerisindeki ifade --- çıkarım yapılan tür
			'L-Value Expression' 		 			 => 'T&'  // O ifadenin türünden 'L-Value Referance'.
			'PR-Value Expression'   	 			 => 'T'   // O ifadenin türünün kendisi.
			'X-Value Expression' 			 		 => 'T&&' // O ifade türünden 'R-Value Referance'.
				* Örnek 1,
					// Some codes here...
					
					int&& foo();
					
					int main()
					{
						decltype(102) tempVar;
						// 'decltype' parantezi içerisindeki deyimin değer kategorisi 'PR-Value', türü de 'int' olduğundan
						// dolayı, tür çıkarımı 'int' şeklinde.
						// int tempVar;
						
						int x = 100;
						int* ptr = &x;
						decltype(*ptr) tempVarTwo;
						// 'decltype' parantezi içerisindeki deyimin kategorisi 'L-Value', türü de 'int' olduğundan dolayı,
						// tür çıkarımı 'int&' şeklinde.
						// int& tempVarTwo;       
						// Fakat referanslara ilk değer vermek zorunlu olduğundan bu durum sentaks hatası oluşturur.
						
						decltype(x) tempVarThree;
						// İlgili parantez içerisinde bir isim olduğundan, çıkarım yapılan tür 'int' türünden.
						// int tempVarThree;
						
						decltype((x)) tempVarFour;
						// İlgili parantez içerisindeki bir ifade olduğundan ve 'L-Value Expression' kategorisinde
						// olduğundan, çıkarım yapılan tür 'int&'.
						// int& tempVarFour;  Fakat ilk değer vermediğimiz için sentaks hatası.
						
						decltype(foo()) tempVarSix;
						// İlgili parantez içerisindeki ifade 'X-Value Expression' ve türü de 'int' olduğundan dolayı,
						// çıkarım yapılan tür 'int&&' şeklinde.
						// int&& tempVarSix;
					}
		
				>>>>> PROFESYONEL DÜZEYDE BIR IFADENIN 'Value Category' BULMAK IÇIN KULLANABILECEĞIMIZ KOD:
					* Örnek 1,
						#define pvc(x)	(
							std::cout << "value category of '" #x << "' is : " << Valcat<decltype((x))>::pvcat << "\n"
						)
						// ' #s ' converts the argument into double quotation mark, aka 'Stringizing operator (#)'

						template<typename T>
						struct Valcat {
						  constexpr static const char *pvcat = "R value";
						};

						template<typename T>
						struct Valcat<T &> {
						  constexpr static const char *pvcat = "L value";
						};

						template<typename T>
						struct Valcat<T&&> {
						  constexpr static const char *pvcat = "X value";
						};

						#include <iostream>

						int main()
						{
						  int x = 10;
						  int y = 20;
						  int *ptr = &x;

						  pvc(x);
						  pvc(++x);
						  pvc(x++);
						  pvc((x,y));
						  pvc(*ptr);
						}

					* Örnek 2,
						//..
						#define pvc(x)	(
							std::cout << "The Result of (" << #x
							<< ") = " << (x) << ", "
							<< Valcat<decltype((x))>::pvcat << "\n"
						)
						// #x ifadesi, argüman olan ifadeyi bir yazıya çevirmiştir.
						// (x) ifadesi, argüman olan ifadenin hesaplanmış halidir.

						template<typename T>
						struct Valcat {
						constexpr static const char *pvcat = "R value";
						};

						template<typename T>
						struct Valcat<T &> {
						constexpr static const char *pvcat = "L value";
						};

						template<typename T>
						struct Valcat<T&&> {
						constexpr static const char *pvcat = "X value";
						};

						#include <iostream>

						int main()
						{
							/*
								# OUTPUT #
								The Result of (x) = 10, L value
								The Result of (++x) = 11, L value
								The Result of (x++) = 11, R value
								The Result of ((x,y)) = 20, L value
								The Result of (*ptr) = 12, L value
							*/
							int x = 10;
							int y = 20;
							int *ptr = &x;

							pvc(x);
							pvc(++x);
							pvc(x++);
							pvc((x,y));
							pvc(*ptr);
						}
