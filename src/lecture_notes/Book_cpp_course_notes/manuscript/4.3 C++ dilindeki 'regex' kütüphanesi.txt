> 'std::regex' kütüphanesi : İş bu kütüphane metin üzerinde 'validation', 'search', 'replacement', 'tokenizing' gibi
işlemlerde kullanılır. Bir hayli büyük bir kütüphane olduğundan temkinli yaklaşmamız, bu kütüphaneye muhtaç isek kullanmamız
gerekmektedir. 'regex' notasyonu pratiği için "regex101.com" sitesini kullanabiliriz. 'regex' notasyonu ile bir kural
betimlenmektedir ve bu kural yukarıdaki işlemlerde kullanılmaktadır. Güvenilir kaynaklardan, başkalarının yazdığı
notasyonları da kullanabiliriz.
	>> Notasyonda kullanılan 'meta' karakterler, yani kendi öz anlamı haricinde notasyon içerisinde kullanıldığında kazandığı
	anlamlar:
		#	        Karakter       |       Kattığı Anlam											
		1.	.		        	   | "Any character except 'newline' " 
		2.	[...]           	   | "One of the characters... (may contain ranges)" 
		3.	[^...]            	   | "None of the characters... (may contain ranges)"
		4.	[[:charclass:]]		   | "A character of the specified character class 'charclass' "
		5.	\n, \t, \f, \r, \v 	   | "A newline, tabulator, form feed, carriage return, or vertical tab"
		6.	\xhh, \uhhh            | "A hexadecimal or Unicode character"
		7.	\d, \D, \s, \S, \w, \W | "A shortcut for a character of a character class"
			
		8.	*                      | "The previous character or group any times"
		9.	?                      | "The previous character or group optional (none or one times)"
		10.	+                      | "The previous character or group at least one time"
		11.	{n}					   | "The previous character or group n times"
		12.	{n,}				   | "The previous character or group at least n times"
		13.	{n,m}				   | "The previous character or group at least n times at most m times"
		14.	...|...				   | "The pattern before or the pattern |"
			
		15.	(...)                  | "Grouping"
		16.	\1, \2, \3             | "The 'nth' group (first group has index 1)"
			
		17.	\b                     | "A positive word boundary (beginning or end of a word)"
		18.	\B                     | "A negative word boundary (no beginning or end of a word)"
		19.	^                      | "The beginning of a line (includes beginning of all characters)"
		20.	$                      | "The end of a line (includes end of all characters)"
	
		* Örnek 1, iş bu 'meta' karakterleri kendi öz anlamları olarak kullanmak için kendilerini "'\'" atomu ile birlikte
		kullanmalıyız. Örneğin, ".zge" bir notasyon olsun. Burada sistem dört harfli fakat son üç harfi 'zge' olan bütün
		kelimeleri bulacaktır. Eğer bizler '.zge' kelimesinin bulunmasını istiyorsak "\.zge" şeklinde bir notasyon
		kullanmalıyız. Benzer şekilde "[zge" şeklindeki notasyon '[zge' kelimesini ARAMAYACAKTIR. Onun için "\[zge" şeklinde
		bir notasyon kullanmalıyız.
		
		* Örnek 2, '.' karakteri yerine bütün karakterler gelebilir ama '\n' hariç. ".zge" şeklindeki bir notasyon 'özge'
		ismini, 'izge' ismini, 'ezge' ismini vs. isimleri doğrulayacaktır.
		
		* Örnek 3, '[]' arasına yazılan karakterleri içeren kelimeler doğrulanacaktır. "k[aei]r" şeklindeki bir notasyon
		'kar', 'ker', 'kir' vs. şeklindeki kelimeleri doğrulayacaktır.
		
		* Örnek 4, '[^]' arasına yazılan karakterleri içermeyen kelimeler doğrulanacaktır. "k[^aei]r" şeklindeki notasyon
		'kor' kelimesini doğrulayacaktır. 'kar', 'ker' ve 'kir' kelimeleri doğrulanmayacaktır.
			
		* Örnek 5, '[-]' şeklindeki notasyon ise şu şekildedir. '-' atomunun önündeki ve arkasındaki harfler bir 'range'
		oluşturuyor. Bu 'range' içerisindeki harflerden birini barındıranlar doğrulanmış oluyor. "k[d-m]r" şeklindeki
		notasyon, 'd' ve 'm' karakteri arasındaki karakterleri içeren kelimeleri doğrulamaktadır. "k[defgğhıijklm]r" şeklinin
		kısa yazımı.
		
		* Örnek 6, '[^-]' şeklindeki notasyon ise yukarıdaki kullanımın tersidir. Aralıktaki harfleri içermeyen kelimeler
		doğrulanır.
		
		* Örnek 7, "k[yqa-f0-9]r" şeklindeki notasyon öyle kelimeleri doğrulayacaktır ki bu kelimeler 'y' ve 'q' harflerini,
		'a' ve 'f' arasındaki harflerden herhangi biri ve '0' ve '9' arasındaki rakamlardan herhangi birini.
		
		* Örnek 8, yukarıdaki tablonun beşinci satırındaki karakterler C dilindeki aynı anlamlara sahiptirler. 
		
		* Örnek 9, yukarıdaki tablonun yedinci satırındaki karakterler özel anlam taşımaktadırlar. '\d' karakterinin notasyon
		içindeki anlamı 'digit' manasındadır. Yani "ar[0-9]xy" notasyonu aslında "ar\dxy" notasyonu şeklinde de yazılabilir.
		'r' ve 'x' kelimelerinin arasına bir rakam karakteri olması gerekmektedir. '\D' ise '\d' karakterinin 'NOT' versiyonu
		gibidir. Geldiği yerde rakam olmaması gerekmektedir. "ar[^0-9]xy" demek aslında "ar\Dxy" demektir.
			
		* Örnek 10, yukarıdaki tablonun yedinci satırındaki '\s' karakteri ise boşluk karakteri manasındadır. "\d\s\d"
		notasyonu '9 9' şeklindeki yazıyı doğrulayacaktır. '\S' karakteri ise 'non-white-character' manasındadır. Boşluk
		karakteri olmayan karakter demektir.
			
		* Örnek 11, yukarıdaki tablonun yedinci satırındaki	'\w' ise alfanumerik ya da '_' karakteri manasındadır.
		"[A-Za-z0-9_]" şeklindeki notasyon ile aynı manadadır. Herhangi bir büyük harf karakteri olabilir, herhangi bir küçük
		harf karakter olabilir, herhangi bir rakam karakteri olabilir ve '_' karakterini içermelidir. '\W' ise bunun 'NOT'
		versiyonudur.
		
		* Örnek 12, yukarıdaki tablonun sekizinci satırındaki '*' atomu, kendisinden önce gelen karakterden herhangi bir
		miktarda bulunabileceğini söylemektedir. "ba*k" şeklinde bir notasyonumuz olsun. Bununla 'bk', 'bak', 'baaaaaaaaak'
		vs. şeklindeki kelimeleri doğrulayabiliriz. ".*" şeklindeki karakterimiz ise herhangi bir karakterden herhangi
		miktarda olan kelimeleri doğrulamaktadır.
			
		* Örnek 13, yukarıdaki tablonun dokuzuncu satırındaki '?' atomu, kendisinden önce gelen karakter ya bir tane olacak
		ya da hiç olmadığı zaman doğrulamayı sağlatacaktır. "ba?k" şeklindeki notasyon sadece 'bak' ve 'bk' kelimelerini
		doğrulayacaktır.
		
		* Örnek 14, yukarıdaki tablonun onuncu satırındaki '+' atomu, kendisinden önce gelen öğeden bir yada birden fazla
		olması anlamına gelmektedir. "ba+k" şeklindeki notasyon 'bak', 'baaaaaaaaak' 'baaaaaaaaaaaaaaaaaaaak' şeklindeki
		kelimeleri doğrulamaktadır. 
			
		* Örnek 15, yukarıdaki tablonun on üçüncü satırındaki '{n,m}' kullanım biçimi bir nevi 'range' işlevi görmektedir.
		Kendisinden önce gelen öğeden ilgili 'range' içerisindeki adet kadar olması manasına gelir. "ba{3, 6}k" şeklindeki
		notasyon sadece 'baaak', 'baaaak',  'baaaaak' vs 'baaaaaak' kelimelerini doğrulamaktadır.
		
		* Örnek 16, yukarıdaki tablonun onbirinci satırındaki '{n}' kullanım biçimi kendisinden önce gelen karakterin olması
		gerektiği adedi belirtir. "ba{3}k" şeklindeki notasyon sadece ve sadece 'baaak' kelimesini doğrulamaktadır.
			
		* Örnek 17, yukarıdaki tablonun onikinci satırındaki '{n,}' kullanım biçimi ise kendisinden önce gelen karakterin
		olması gereken minimum adedini belirtir. "ba{3,}k" şeklindeki notasyon 'baaak', 'baaaaaaak' vs. şeklindeki kelimeleri
		doğrulamaktadır.
			
		* Örnek 18, yukarıdaki tablonun ondördüncü satırındaki '...|...', ya sol tarafındaki varlık ya da sağ tarafındaki
		varlık kelime içerisinde olacaktır. "a|e" şeklindeki notasyon, bünyesinde 'a' ve 'e' karakterlerini barındıran
		kelimeleri doğrulayacaktır. "([a-e]{3,4})|([s-z]{2,})" şeklindeki notasyon 'a' ve 'e' arasındaki karakterlerden en az
		üç, en fazla dört adet içeren veya 's' ve 'z' arasındaki karakterlerden en az iki tane içeren kelimeleri
		doğrulayacaktır.
			
		* Örnek 19, yukarıdaki tablonun onyedinci satırındaki '\b' kelime sınırı demektir. "\bpro" şeklindeki notasyon
		'pro', 'proje' kelimesini doğrular fakat 'apron' kelimesini doğrulamaz. İlgili atomu sonda kullandığımız zaman ise
		bittiği yeri göstermektedir. Yani, "bin\b" şeklindeki notasyon 'binali' kelimesini doğrulamaz ama 'kabin' kelimesini
		doğrulayacaktır.
			
		* Örnek 20, yukarıdaki tablonun onsekizinci satırındaki	'\B', kelime başı veya kelime sonu olmayan demektir.
		Yukarıdakinin tersi manasındadır. 
			
		* Örnek 21, yukarıdaki tablonun ondokuzuncu satırındaki '^' satırın başında olursa eğer kendisinden sonrakilerin
		satırın başında olması durumunda doğrulamaktadır. "^pr[aoei]" şeklindeki notasyon,
			"proje profosyonel programcılar tarafından ele alınıyor apronda bekliyoruz" 
		cümlesindeki sadece cümlenin başındaki 'proje' kelimesi içindeki 'pro' yu bulacaktır.
		
		* Örnek 21, yukarıdaki tablonun ondokuzuncu satırındaki	'$' ise yukarıdaki senaryonun satırın sonunda olması
		durumudur.
		
		* Örnek 22, yukarıdaki tablonun onbeşinci satırındaki '()' atomu öncelik etkisi yapmaktadır. "(ar){2,4}" şeklindeki
		notasyon bünyesinde en az iki en çok dört tane 'ar' kelimesini içeren kelimeleri onaylayacaktır. Bir diğer anlamı da
		parantez içerisine yazdıklarımız 'regex' motoru tarafından ayrıca değerlendirilmektedir. "[1-5]{3}ar[d-h]{2}"
		şeklindeki notasyon şu anlamı taşımaktadır; Bir ve beş arasındaki rakamlardan üç adet, 'a' ve 'r' karakterleri, 'd'
		ve 'h' arasındaki karakterlerden iki adet içerenlerin doğrulanması. Velevki notasyonumuz "([1-5]{3})ar([d-h]{2})"
		şeklinde olsaydı anlam olarak bir değişiklik oluşmayacaktı fakat uygun kelimeleri bulduğu zaman sol taraftaki
		parantez içerisindekileri ayrıca, sağ parantez içerisindekileri ayrıca işleyebiliyorum. Bir nevi alt birim haline
		getiriyoruz. Eğer bizler bu ikinci anlamı kullanmak istemiyorsak, sadece ve sadece öncelik parantezi olarak kullanmak
		istiyorsak, parantezin açıldığı yere '?:' atomunu ekliyoruz. "?:[1-5]{3}". 
			
		* Örnek 23, yukarıdaki tablonun altıncı satırındakiler ise 'back_inserter' işlevi görmekteler. Kendilerinden önce ne
		varsa, bulundukları yerde de o kelimeler olacaktır.
			
	>> Pekiştirici örnekler '(regex101.com)' isimli internet sitesi kullanılmıştır.
		* Örnek 1, "a[etms]b" şeklindeki notasyon 'atb' ve 'aeb' kelimelerini doğrulayacaktır fakat 'alb' kelimesini
		doğrulamayacaktır.
		
		* Örnek 2, "pr[aoei]" notasyonu 'proje', 'apron', 'alpro' kelimelerini doğrulamaktadır.
		
		* Örnek 3, "\bpr[aoei]" notasyonu ise yukarıdaki 'proje', 'apron' ve 'alpro' kelimelerinden SADECE 'proje' kelimesini
		doğrulayacaktır.
			
		* Örnek 4,	"pr[aoei]\b" notasyonu ise yukarıdaki 'proje', 'apron' ve 'alpro' kelimelerinden SADECE 'alpro'
		kelimesini doğrulayacaktır.
			
		* Örnek 5, "\bpr[aoei]\b" notasyonu ise yukarıdaki 'proje', 'apron' ve 'alpro' kelimelerinden HİÇ BİRİNİ
		doğrulamayacaktır fakat 'pro' kelimesini doğrulayacaktır.
			
		* Örnek 6, C dilinde 'if' deyiminden hemen sonra ';' atomunun yazılıp yazılmadığının kontrolü;
			Notasyon : "if\s*\(.*\)\s*;"
			Anlamı   : "if...", 'i' ve 'f' karakterlerini içerecek,
					   "if\s*...", 'i' ve 'f' karakterlerinden sonra herhangi miktarda boşluk karakteri içerebilir,
					   "if\s*\(...", yukarı deyimin devamında '(' atomu gelmeli,
					   
					   "if\s*\(.*...", yukarıdaki deyimdeki '(' atomundan sonra herhangi bir karakterden sonra herhangi
						miktarda karakter gelebilir.
					   
					   "if\s*\(.*\)...", yukarıdaki deyimdeki bahsi geçen karakterlerden hemen sonra ')' atomu gelmeli.
					   
					   "if\s*\(.*\)\s*", yukarıdaki deyimde bahsi geçen ')' atomundan hemen sonra herhangi miktarda boşluk
						karakteri gelebilir.
					 
					   "if\s*\(.*\)\s*;", yukarıdaki deyimde bahsi geçen boşluk karakterinden sonra ';' atomu gelmeli.
					   
			if (x > 5)   ; // Bunu doğrulayacaktır.

			ifs(a>b)            ;

			if (x > 10)
			   ++y;

			if    (x > 5); // Bunu doğrulayacaktır.
				a++
			if(1); // Bunu doğrulayacaktır.


			if (x > y)  ;  { // Bunu doğrulayacaktır.
		
		* Örnek 7, 0-255 aralığındaki sayıları buldurma;
			Notasyon :	"\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b"
			Anlamı   :	"\b(...)\b", parantez içerisindekilerin hem başlangıç hem de bitiş olarak kullanılması.
					   
						"\b([0-9]|...)\b", '0' ve '9' arasındaki rakamlar ile başlayacak, '0' ve '9' rakamları arasındakiler
						DOĞRULANACAKTIR. 
						
						"\b([0-9]|[1-9][0-9]|...)\b", veya '1' ve '9' arasındaki rakamlar ve '0' ve '9' arasındaki rakamlar
						ile başlayacak, '10' ve '99' arasındaki sayılar DOĞRULANACAKTIR. 
					    
						"\b([0-9]|[1-9][0-9]|1[0-9][0-9]|...)\b", veya '1' rakamı ile başlayacak ve devamında bir adet '0'
						ve '9' arasındaki ve bir adet '0' ve '9' arasındaki rakamlar olacak, '100' ile '199' arasındaki
						sayılar DOĞRULANACAKTIR.  
					    
						"\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|...", veya '2' rakamı ile başlayacak ve devamında bir
						adet '0' ve '4' arasındaki rakam olacak ve bir adet '0' ve '9' arasındaki rakamlar olacak, '200' ile
						'249' arasındaki sayılar DOĞRULANACAKTIR. 
					    
						"\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b", veya '25' rakamı olacak ve devamında da bir
						adet '0' ve '5' arasındaki rakamlar olacak, '250' ile '255' arasındaki sayılar DOĞRULANACAKTIR. 
					
			0 // Bunu doğrulayacaktır.
			1 // Bunu doğrulayacaktır.
			123 // Bunu doğrulayacaktır.
			255 // Bunu doğrulayacaktır.
			256
			012
			87 // Bunu doğrulayacaktır.
			99 // Bunu doğrulayacaktır.
			111 // Bunu doğrulayacaktır.
			1112
			777
			783487943
			
		* Örnek 8, Geçerli Tarih sorgulaması:
			Notasyon :	"(0[1-9]|[12][0-9]|3[01])([-.\/])(0[1-9]|1[012])\2(19|20)\d\d"
			Anlamı   :	"(...)(...)(...)", şeklinde büyük resme bakarsak;
					   
						"(0[1-9]|[12][0-9]|3[01])...", İlk başa '0' karakteri, devamında '1' ve '9' rakamları arasındaki
						rakamlardan birisi, '01' ve '09' rakamları arasındakiler veya '1' ve '2' rakamları ve '0' ile '9'
						rakamları arasındaki bir rakam, '10' ile '29' arasındakiler veya '3' rakamı, '0' ve '1' rakamları,
						'30' ve '31' rakamlarından birisi
					   
						"(0[1-9]|[12][0-9]|3[01])([-./])...", yukarıdaki notasyonun devamında '-', '.' veya '/' karakterinden
						birisi gelebilir.(BİRİNCİ 'capture-point')
					   
						"(0[1-9]|[12][0-9]|3[01])([-./])(0[1-9]|1[012])...", yukarıdaki notasyona ek olarak '0' karakteri ve
						devamında '1' ile '9' arasındaki karakterlerden birisi, '01' ile '09' arasındaki rakamlardan birisi
						veya '1' karakteri ile '0', '1' ve '2' karakterlerinden birisi, '10', '11' veya '12' rakamlarından
						birisi.
					   
						"(0[1-9]|[12][0-9]|3[01])([-./])(0[1-9]|1[012])\2...", yukarıdaki notasyona ek olarak
						'back_reference' işlevi görmektedir. Eğer bu işlev yerine "([-./])" notasyonunu kullansaydık gün-ay
						arasındaki ayraç ile ay-yıl arasındaki ayraç farklı olması durumunda da doğrulama yapılacaktı.
						'back_reference' ile bunun önüne geçmiş oluyoruz. Birinci 'capture-point' de ne olduysa bu noktada da
						aynısı olacaktır.
					   	
						"(0[1-9]|[12][0-9]|3[01])([-./])(0[1-9]|1[012])\2(19|20)...", yukarıdaki notasyona ek olarak ya '19'
						sayısı ya da '20' sayısı olacak.
					   	
						"(0[1-9]|[12][0-9]|3[01])([-./])(0[1-9]|1[012])\2(19|20)\d\d", yukarıdaki notasyona ek olarak
						herhangi iki rakam gelebilir.
			
			05.12.1998 // Bunu doğrulayacaktır.
			05-1987
			01.11.1998 // Bunu doğrulayacaktır.
			12.05.1000
			
		* Örnek 9, Geçerli gerçek sayı olup olmadığının testi:
			Notasyon :	"[-+]?[0-9]*\.?[0-9]+"
			Anlamı   :	"[-+]...", '-' veya '+' karakterinin birisinin olması,
					   	"[-+]?...", yukarıdaki karakterlerden bir tane veya hiç olmaması durumu,
					   	
						"[-+]?[0-9]...", yukarıdaki notasyonun devamında '0' ve '9' rakamlarının arasındaki rakamlardan
						birisinin olması durumu,
					   	
						"[-+]?[0-9]*...", yukarıdaki notasyonun devamında, kendinden önce gelen rakamdan herhangi bir adet
						kadar olması,
					   	
						"[-+]?[0-9]*\....", yukarıdaki notasyonun devamında, sadece '.' atomunun gelmesi.
					   	
						"[-+]?[0-9]*\.?...", yukarıdaki notasyonun devamında, '.' atomundan ya bir tane ya da hiç olmaması
						durumu,
					   	
						"[-+]?[0-9]*\.?[0-9]", yukarıdaki notasyonun devamında, '0' ve '9' rakamlarının arasındaki
						rakamlardan birisinin olması durumu,
					   	
						"[-+]?[0-9]*\.?[0-9]+", yukarıdaki notasyonun devamında, ilgili karakterlerden en az bir tane
						olması durumudur.
					   
			2.4 // Bunu doğrulayacaktır.
			0.7832487 // Bunu doğrulayacaktır.
			-78234.87234 // Bunu doğrulayacaktır.
			87934.2 // Bunu doğrulayacaktır.
			78345 // Bunu doğrulayacaktır.
			-83.234 // Bunu doğrulayacaktır.
			+73.87234 // Bunu doğrulayacaktır.
			0 // Bunu doğrulayacaktır.
			0.0 // Bunu doğrulayacaktır.
			
		* Örnek 10, C dilinde hexadecimal sabit belirtiyor mu?
			Notasyon :	"\b0[xX][0-9a-fA-F]+\b"
			Anlamı   :	"\b0...", kelime başının '0' karakteri olması zorunlu.
					   	"\b0[xX]...", devamında 'x' veya 'X' karakterlerinden birisinin gelmesi zorunlu.
					   	
						"\b0[xX][0-9a-fA-F]...", devamında ise '0' ve '9' rakamları arasındaki rakamlardan birisi, 'a' ve 'f'
						harfleri arasındaki harflerden bir tanesi ve 'A' ve 'F' harfleri arasındaki harflerden bir tanesi
						olmak zorunda.
					   	
						"\b0[xX][0-9a-fA-F]+...", yukarıdaki notasyondan en az bir tane olmak zorunda.
					   	"\b0[xX][0-9a-fA-F]+\b", kelime bitişinin de yukarıdaki notasyon olmak zorunda.
					   
		* Örnek 11, C dilindeki anahtar sözcükleri bulan notasyon
			Notasyon : "(\bauto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|
			int|long|register|restrict|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|
			while|_Bool|_Complex|_Imaginary\b)"
			Anlamı   : https://regex101.com/r/gQcHz1/1
		
		* Örnek 12, Gerçek sayı olup olmadığı sınamaktadır.
			Notasyon : "[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?"
			Anlamı   : https://regex101.com/r/1QMAbw/1/
			
	>> C++ dilindeki kullanımı: Gerek Cpp dilinde gerek 'regex' notasyonunda '(\)' karakteri özel anlam taşıdığı için
	karakterin, kendisini kullanmamız için, '\\' şeklinde bir kullanım sergilememiz gerekmektedir. Örneğin, elimizde '\\\s'
	şeklinde bir 'regex' notasyonu olsun. Bunun anlamı şudur, '(\)' karakterinin kendisi ve '\s' karakteri. Eğer bunu Cpp
	dilinde bir 'string' olarak işlemek istersek "\\\\\\s" olacaktır. Çünkü soldak ilk dört '(\)' karakteri aslında 'regex'
	notasyonunda '\\' karşılığı. Devamında gelen '\\s' ise '\s' nin karşılığı. Böylelikle Cpp dilindeki "\\\\\\s" nin 'regex'
	karşılığı '\\s' şeklinde. Bunun anlamı da '\ ' karakterinin yazı içerisinde aranması demektir. İşte bu karmaşayı önlemek
	için Cpp dilinde 'raw-string literals' şeklinde bir aracı vardır. Bu aracın kullanımı da şu şekildedir; 'R"(...)"',
	buradaki '...' yerine direkt olarak 'regex' notasyonunu yaza biliriz. 
		* Örnek 1,
			//..
			int main() 
			{
				/*
					# OUTPUT #
					"ali"  \nigde\
				*/
				
				const char* regexNotaion{ R"("ali"  \nigde\)" };
				
				std::cout << regexNotaion << std::endl;
				
				return 0;
			}
			
		* Örnek 2,
			//..
			int main() 
			{
				/*
					# OUTPUT #
					
					Korkma, sönmez bu şafaklarda yüzen al sancak;
					Sönmeden yurdumun "üstünde" tüten en son ocak.
					O benim milletimin yıldızıdır, parlayacak;
					O benimdir, o benim milletimindir ancak.
				*/
				
				const char* regexNotaion{R"(
											Korkma, sönmez bu şafaklarda yüzen al sancak;
											Sönmeden yurdumun "üstünde" tüten en son ocak.
											O benim milletimin yıldızıdır, parlayacak;
											O benimdir, o benim milletimindir ancak.
											)"
										};
				
				std::cout << regexNotaion << std::endl;
				
				return 0;
			}
			
		* Örnek 3,
			//..
			int main() 
			{
				/*
					# OUTPUT #
					another
					brother
					example
					measure
					meeting
					prepare
					present
					president
					pressure
					property
					protect
					question
					statement
					station
					whatever
					whether
				*/
				
				auto wordList{ get_dictionary("wordList.txt") };
				
				std::cout << "Our word list contains " << wordList.size() << " words." << std::endl;
				
				std::regex myRegexNotaion{ ".{2}[aeio][tmps].{3,5}" };
				// Argüman olarak direkt olarak bir 'regex' notasyonu geçilmektedir.
				// ".", herhangi bir karakterden bir adet
				// ".{2}", yukarıdaki notasyondan iki adet. Yani iki adet herhangi bir karakter
				// ".{2}[aeio]...", yukarıdaki notasyona ek olarak 'a', 'e', 'i' ve 'o' karakterlerinden birini içermesi

				// ".{2}[aeio][tmps]...", yukarıdaki notasyona ek olarak 't', 'm', 'p' ve 's' karakterlerinden birini
				// içermesi
				
				// ".{2}[aeio][tmps]. ...", herhangi bir karakterden bir adet"
				
				// ".{2}[aeio][tmps].{3,5}", yukarıdaki notasyonu sağlayan en az üç, en fazla beş adet. Yani herhangi bir
				// karakterden en az üç, en fazla beş adet.

				for(const auto& word : wordList)
				{
					// 'std::regex_match', yazılan 'regex' notasyonuna göre kapta arama yapmaktadır.
					if( std::regex_match(word, myRegexNotaion) )
					{
						std::cout << word << std::endl;
					}
				}
				
				return 0;
			}
			
		* Örnek 4, 
			//..
			int main() 
			{
				/*
					# OUTPUT #
					Our word list contains 1005 words.
					aaabbbcccardddeeeffftion
					farmation
				*/
				
				auto wordList{ get_dictionary("wordList.txt") };
				
				std::cout << "Our word list contains " << wordList.size() << " words." << std::endl;
				
				std::regex myRegexNotaion{ ".*ar.*tion.*" };
				// Argüman olarak direkt olarak bir 'regex' notasyonu geçilmektedir.
				// ".*...", herhangi bir karakterden 'n' kadar
				// ".*ar...", devamında 'ar' kelimesi
				// ".*ar.*...", devamında ise herhangi bir karakterden 'n' kadar
				// ".*ar.*tion...", devamında 'tion' kelimesi
				// ".*ar.*tion.*", devamında ise herhangi bir karakterden 'n' kadar

				for(const auto& word : wordList)
				{
					// 'std::regex_match', yazılan 'regex' notasyonuna göre kapta arama yapmaktadır.
					if( std::regex_match(word, myRegexNotaion) )
					{
						std::cout << word << std::endl;
					}
				}
				
				return 0;
			}
			
		* Örnek 5,
			//..
			int main() 
			{
				/*
					# OUTPUT #
					New regex notation : .*A.*h.*m.*e.*t.*
					Our word list contains 1005 words.
					ssssAeeehfffmgggehhht
				*/
				
				std::string regexNotationStr{".*"}; // Bu nesne bir 'regex' notasyonu olarak kullanılacak.
				const std::string name{"Ahmet"};
				for(auto c : name)
				{
					regexNotationStr += c;
					regexNotationStr += ".*";
				}
				std::cout << "New regex notation : " << regexNotationStr << "\n";
				
				std::regex myRegexNotaion{ regexNotationStr };
				
				auto wordList{ get_dictionary("wordList.txt") };
				std::cout << "Our word list contains " << wordList.size() << " words." << std::endl;
															 
				for(const auto& word : wordList)
				{
					// 'std::regex_match', yazılan 'regex' notasyonuna göre kapta arama yapmaktadır.
					if( std::regex_match(word, myRegexNotaion) )
					{
						std::cout << word << std::endl;
					}
				}
				
				return 0;
			}

    Bu kütüphaneye ilişkin diğer özellikler şunlardır:
        >>> Eğer geçersiz bir 'regex' notasyonunu sınıfın kurucu işlevine argüman olarak geçersek, bir hata nesnesi
        gönderilecektir.
            * Örnek 1,
                //..
                int main() 
                {
                    /*
                        // 'raw-string literal' olarak kullanmadık. Dolayısıyla '\.' hata oluşturacak.
                        # OUTPUT #
                        main.cpp: In function ‘int main()’:
                        main.cpp:11:22: warning: unknown escape sequence: '\.'
                        11 |      std::regex rgx{ "[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?" };
                            |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    */
                    
                    try{
                        
                        std::regex rgx{ "[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?" };
                        // 'raw-string literal' olarak kullanmadık. Dolayısıyla '\.' hata oluşturacak.
                        // Bunun için ya 'raw-string literal' yada '\\.' yazmamız gerekiyor.
                        // Bu hali ile sentaks hatası.
                        
                    }catch(const std::exception& ex)
                    {
                        std::cout << "Hata yakalandi... " << ex.what() << std::endl;
                    }
                    
                    return 0;
                }

		>>> 'sub-group' veya 'capture-point' bilgilerinin elde edilmesi: Sınıfın '.mark_count()' isimli üye fonksiyonu ile
		bunu gerçekleştirebiliriz.
			* Örnek 1,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						capture-point : 2         
					*/
					
					// En sağdaki parantez çifti 'capture-point' işlevi değil, sadece öncelik parantezidir.
					std::regex rgx{ "(Ahmet)(Kandemir)(?:Pehlivanli)" };
					
					std::cout << "capture-point : " << rgx.mark_count() << "\n";
					
					return 0;
				}
				
			* Örnek 2,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						capture-point : 4     
					*/
					
					std::regex rgx{ "(Ah(m)et)(Kandemir)(Pehlivanli)" }; 
					
					std::cout << "capture-point : " << rgx.mark_count() << "\n";
					
					return 0;
				}
				
		>>> 'std::regex' sınıfın kurucu işlevine geçilen 'std::regex_constant' isim alanında tanımlı bazı bayraklar vardır.
			* Örnek 1,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						capture-point : 0    
					*/
					
					// 'nosubs' isimli bayrak, 'capture-point' leri görmezden geldirmektedir.
					std::regex rgx{ "(Ah(m)et)(Kandemir)(Pehlivanli)", std::regex_constants::nosubs};
					
					std::cout << "capture-point : " << rgx.mark_count() << "\n";
					
					return 0;
				}
				
			* Örnek 2,
				//..
				int main() 
				{
					std::regex rgx{ "(Ah(m)et)(Kandemir)(Pehlivanli)", std::regex_constants::icase};
					// 'icase' isimli bayrak, notasyonun 'incase sensitive' olmasını sağlar. Yani büyük/küçük harf
					// ayrımı yapmaz.
					
					return 0;
				}

		>>> 'regex' notasyonu ile ARAMA işlemleri: Artık fonksiyonumuzun ismi 'regex_search()' fakat argümanlar
		'regex_match()' ile aynıdır. İş bu fonksiyonun da geri dönüş değeri 'bool' veri tipidir. Fakat ikinci argüman olarak
		artık 'smatch' veya 'cmatch' sınıflarından değişkenler kullanıyoruz ki sonuçlar bu değişkenlere kaydedilsin. Bu
		sınıflar sırasıyla 'std::string' ve 'const char*' tip yazılar için kullanılır.
			* Örnek 1,
				//..
				İçinde arama yapacağımız 'std::string' : "alican7642.fdce.9245enes"
				Kullanacağımız 'regex' notasyonu       : "(\d{4})\.([a-f]{4})\.(\d{4})"
														    ^     ^    ^      ^   ^
															|	  |	   |	  |   | Bir rakam karakteri fakat dört adet.
												 			|	  |	   |	  | '.' karakterinin kendisi.
															|	  |	   | 'a' ve 'f' karakterlerinin arasındaki karakterlerden
															|	  |	   | dört adet.      
															|	  | '.' karakterinin kendisi.	  			   
										          	 	    | Bir rakam karakteri fakat dört adet.
															
				Bulunan yazımız                        : "7642.fdce.9245"
														 |	^ |  ^ |  ^ | 	
														 |  b |  c |  d |
														 |    |    |    |
														 |    |    |    |
														 |    |    |    |
														 |--------------|
														 |        a     |
														 
														a: Bulunan yazının tamamıdır. 'smatch' isimli sınıf bir kap
														olduğundan, '0' indisli öğesi iş bu yazıdır.
														b: İlgili bütün yazının birinci 'sub-match' grubudur. '1' indisli
														öğesi iş bu yazıdır.
														b: İlgili bütün yazının ikinci 'sub-match' grubudur. '2' indisli
														öğesi iş bu yazıdır.
														b: İlgili bütün yazının üçüncü 'sub-match' grubudur. '3' indisli
														öğesi iş bu yazıdır.
														
			* Örnek 2,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						Icinde arama yapilacak yazi :  alican7642.fdce.9245enes
						Regex Notation : (\d{4})\.([a-f]{4})\.(\d{4})
						Capture Points : 3
						Bulunan yazidan onceki metin : alican
						0 indisli oge, [14] => 7642.fdce.9245
						1 indisli oge, [4] => 7642
						2 indisli oge, [4] => fdce
						3 indisli oge, [4] => 9245
						Bulunan yazidan sonraki metin : enes
					*/

					// Bir 'regex' notasyonu kullanarak, bu yazı içerisinde arama yapacağız.
					std::string textToSearchIn{ "alican7642.fdce.9245enes" };
					
					std::cout << "Icinde arama yapilacak yazi :  " << textToSearchIn << std::endl;
					
					// Kullanacağımız 'regex' notasyonu, 'raw-string literal' şeklinde.
					std::string regexNotationString{ R"((\d{4})\.([a-f]{4})\.(\d{4}))" };
					
					std::regex regexNotation{ regexNotationString }; // 'regex' nesnemizi hayata getirdik.
					
					std::cout << "Regex Notation : " << regexNotationString << std::endl;
					std::cout << "Capture Points : " << regexNotation.mark_count() <<  std::endl;
					
					std::smatch mathchResults;
					// Bulunan hakkındaki değerlerin saklanacağı değişkenimiz. 'smatch' kullandığımız için 'std::string'
					// ile işlem yapmalıyız. Bu sınıfımız aslında bir 'container' olup, 'sub-match' isimli sınıfların
					// öğelerinin birleşmesinden meydana gelir. Bir 'container' olduğundan, '.operator[]()' fonksiyonunu
					// çağırabiliriz. '0' indisini argüman olarak geçtiğimiz zaman bulunan yazının tamamını, '1' geçildiğinde
					// birinci 'sub-match' bölümünü, '2' indisini argüman olarak geçtiğimiz zaman ikinci 'sub-match' bölümünü
					// vs. temin edebiliriz.
					
					if( std::regex_search(textToSearchIn, mathchResults, regexNotation) )
					{
						// Aranan ilk kez bulunduğunda programın akışı buraya girecektir. Bütün hepsini bulmak için başka
						// yöntemler denemeliyiz.
						std::cout << "Bulunan yazidan onceki metin : " << mathchResults.prefix() << std::endl;
						
						for(size_t i{}; i < mathchResults.size(); ++i)
						{
							// std::cout << i << " indis konumundaki oge : " << mathchResults[i] << std::endl;
							std::cout << i << " indisli oge, [" 
								<< mathchResults.length(i) << "] => " << mathchResults.str(i) << std::endl;
						}
						
						/*
							for(const auto& subMatch : mathchResults)
							{
								// Döngünün her turunda 'subMatch' isimli değişken aslında 'sub-match'
								// sınıf türünden bir nesne.
								std::cout << sub-match.str() << "\n";
							}
						*/
						
						/*
							for(auto iter{mathchResults.cbegin()}; i != mathchResults.cend(); ++iter)
							{  
								std::cout << iter->str() << "\n"; 
							}
						*/
						
						std::cout << "Bulunan yazidan sonraki metin : " << mathchResults.suffix() << std::endl;
					}
					
					return 0;
				}
				
			* Örnek 3,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						Icinde arama yapilacak yazi :  alican7642.fdce.9245enes
						Regex Notation : (\d{4})\.([a-f]{4})\.(\d{4})
						Capture Points : 3
						Aranan yazi 6 konumunda bulundu.
						Bulunan yazinin ilk kismi : 6 konumunda bulundu.
						Bulunan yazinin ikinci kismi : 11 konumunda bulundu.
						Bulunan yazinin ucuncu kismi : 16 konumunda bulundu.
					*/

					// Bir 'regex' notasyonu kullanarak, bu yazı içerisinde arama yapacağız.
					std::string textToSearchIn{ "alican7642.fdce.9245enes" };
					
					std::cout << "Icinde arama yapilacak yazi :  " << textToSearchIn << std::endl;
					
					// Kullanacağımız 'regex' notasyonu, 'raw-string literal' şeklinde.
					std::string regexNotationString{ R"((\d{4})\.([a-f]{4})\.(\d{4}))" };
					
					// 'regex' nesnemizi hayata getirdik.
					std::regex regexNotation{ regexNotationString };
					
					std::cout << "Regex Notation : " << regexNotationString << std::endl;
					std::cout << "Capture Points : " << regexNotation.mark_count() <<  std::endl;
					
					// Bulunan hakkındaki değerlerin saklanacağı değişkenimiz. 'smatch' kullandığımız için 'std::string' ile
					// işlem yapmalıyız. Bu sınıfımız aslında bir 'container' olup, 'sub-match' isimli sınıfların öğelerinin
					// birleşmesinden meydana gelir. Bir 'container' olduğundan, '.operator[]()' fonksiyonunu çağırabiliriz.
					// '0' indisini argüman olarak geçtiğimiz zaman bulunan yazının tamamını, '1' geçildiğinde birinci
					// 'sub-match' bölümünü, '2' indisini argüman olarak geçtiğimiz zaman ikinci 'sub-match' bölümünü vs.
					// temin edebiliriz.
					std::smatch mathchResults;
					
					if( std::regex_search(textToSearchIn, mathchResults, regexNotation) )
					{
						std::cout << "Aranan yazi " 
							<< mathchResults.position() << " konumunda bulundu." << std::endl;
						std::cout << "Bulunan yazinin ilk kismi : " 
							<< mathchResults.position(1) << " konumunda bulundu." << std::endl;
						std::cout << "Bulunan yazinin ikinci kismi : " 
							<< mathchResults.position(2) << " konumunda bulundu." << std::endl;
						std::cout << "Bulunan yazinin ucuncu kismi : " 
							<< mathchResults.position(3) << " konumunda bulundu." << std::endl;
					}
					
					return 0;
				}
				
			* Örnek 4,
				//..
				int main() 
				{
					/*
						# out.txt #
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
						7642.fdce.9245
					*/

					// Kullanacağımız 'regex' notasyonu, 'raw-string literal' şeklinde.
					std::string regexNotationString{ R"((\d{4})\.([a-f]{4})\.(\d{4}))" };
					
					std::regex regexNotation{ regexNotationString }; // 'regex' nesnemizi hayata getirdik.
					
					auto textsToSearchIn{ get_str_from_file("notation.txt") };
					
					std::ofstream ofs{"out.txt"};
					if(ofs)
					{
						for(
							std::sregex_iterator iter{textsToSearchIn.cbegin(), textsToSearchIn.cend(), regexNotation}, end; 
							iter != end; 
							++iter
						) {
							ofs << iter->str() << "\n";   
						}
					}
					else
					{
						std::cerr << "Dosya acilamadi...\n"; return 1;
					}
					
					return 0;
				}
				
			* Örnek 5,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						@6, [48] => disa.columbus.ns.mbx.hostmaster-dod-nic@mail.mil
						@55, [48] => disa.columbus.ns.mbx.arin-registrations@mail.mil
						@113, [22] => sergiosouza@ipw.com.br
						@136, [12] => cert@cert.br
						@149, [18] => mail-abuse@cert.br
						@176, [21] => support@caribsurf.com
						@198, [20] => kjones@caribsurf.com
						@227, [23] => ipadmin@erfwireless.com
						@251, [19] => jsealy@isp-tech.net
						@279, [28] => itsupport@tonysfinefoods.com
						@316, [25] => it.networking@basspro.com
						@351, [21] => ricardopi@hotmail.com
						@373, [12] => cert@cert.br
						@386, [18] => mail-abuse@cert.br
						@424, [29] => tanveer.rahman@novocom-bd.com
						@461, [48] => disa.columbus.ns.mbx.arin-registrations@mail.mil
						@537, [26] => jodhingo@agra-alliance.org
						@564, [26] => skisonzo@agra-alliance.org
						@591, [15] => amaina@agra.org
						@607, [17] => skisonzo@agra.org
						@633, [19] => support@esedona.net
						@653, [17] => abuse@esedona.net
						@722, [15] => hiou@viasat.com
						@738, [24] => wildblueabuse@viasat.com
						@774, [14] => odd@viasat.com
						@789, [22] => wildbluenoc@viasat.com
						@821, [21] => mcouto@nowtech.com.br
						@843, [12] => cert@cert.br
						@856, [18] => mail-abuse@cert.br
						@883, [19] => lgurley@flocorp.com
						@919, [16] => abuse@rogers.com
						@936, [24] => tecpro@rogerstelecom.net
						@961, [21] => noc@rogerstelecom.net
						@983, [23] => abuse@rogerstelecom.net
						@1007, [24] => dsl.ip@rogerstelecom.net
						@1039, [18] => dpieper@exwire.com
						@1058, [16] => abuse@exwire.com
						@1075, [18] => support@exwire.com
						@1102, [32] => bob.gelety@clarkconstruction.com
						@1135, [17] => pfeul@clarkus.com
						@1177, [17] => ip-req@sprint.net
						@1195, [19] => ipsa.noc@sprint.com
						@1223, [14] => abuse@i4hk.com
						@1238, [13] => info@i4hk.com
						@1306, [15] => daz@emswifi.com
						@1330, [17] => jnguyen@crpud.org
						@1355, [18] => jlynnsh@igctel.com
						@1391, [26] => netadmin@tractorsupply.com
						@1434, [20] => khatfield@socllc.net
						@1455, [16] => abuse@socllc.net
						@1507, [26] => ark.theobald@harlandfs.com
						@1551, [24] => ayman.louis@ca-egypt.com
						@1577, [24] => aged.tammam@ca-egypt.com
						@1620, [19] => abuse@infoquest.com
						@1640, [21] => support@infoquest.com
						@1662, [22] => lmelhorn@infoquest.com
						@1702, [15] => info@wit.net.my
						@1726, [27] => support@flatplanetphone.com
						@1754, [25] => abuse@flatplanetphone.com
						@1780, [23] => noc@flatplanetphone.com
						@1830, [28] => robertshutt@quinnemanuel.com
						@1859, [19] => support@perivue.com
						@1913, [14] => julius@mnl.seq
						@1936, [19] => ops@mypublisher.com
						@1992, [24] => aitne@clarisnetworks.com
						@2017, [28] => dstilwill@clarisnetworks.com
						@2053, [20] => mmueller@attmail.com
						@2082, [15] => abuse@onesc.net
						@2098, [16] => netops@onesc.net
						@2115, [22] => hostmaster@onestep.net
						@2154, [24] => arin.noc@radialpoint.com
						@2179, [25] => arin.tech@radialpoint.com
						@2205, [26] => arin.abuse@radialpoint.com
						@2249, [19] => sanjay@nec-labs.com
						@2277, [22] => abuse-mail@townisp.com
						@2300, [21] => arin-tech@townisp.com
						@2322, [14] => sdorsey@ci.shr
						@2345, [31] => network_management@homedics.com
						@2385, [20] => lhamilton@teainc.org
						@2414, [18] => meira@fonar.com.br
						@2433, [12] => cert@cert.br
						@2446, [18] => mail-abuse@cert.br
						@2473, [22] => arin-admin@skybeam.com
						@2496, [17] => abuse@skybeam.com
						@2514, [26] => bplimpton@jabbroadband.com
						@2576, [20] => italerts@liaison.com
						@2614, [23] => lorenzo.piccioli@ctv.ca
						@2646, [13] => noc@mhsfl.net
						@2722, [17] => mahmood@cytel.com
						@2748, [22] => arin.tech@labspace.com
						@2779, [20] => z-netops@zscaler.com
						@2800, [17] => abuse@zscaler.com
						@2818, [16] => bill@zscaler.com
						@2843, [25] => lservello@valuedrugco.com
						@2904, [19] => domadmin@hormel.com
						@2924, [22] => kloldenkamp@hormel.com
						@2947, [20] => sjholtorf@hormel.com
						@2985, [29] => sami.elloumi@orangetunisie.tn
						@3015, [28] => fethi.miled@orangetunisie.tn
						@3044, [30] => marouen.hamza@orangetunisie.tn
						@3083, [20] => eki@orangetunisie.tn
						@3122, [20] => noc@pranasystems.com
						@3143, [25] => bgoldman@pranasystems.com
						@3185, [24] => security@americanbus.com
						@3210, [24] => brichter@americanbus.com
						@3235, [25] => pbarsness@americanbus.com
						@3295, [15] => dgreen@dart.org
					*/

					std::regex regexNotation{ eRegex() }; // 'regex' nesnemizi hayata getirdik.
					
					auto textsToSearchIn{ get_str_from_file("mails.txt") };
					
					for(
						std::sregex_iterator iter{textsToSearchIn.cbegin(), textsToSearchIn.cend(), regexNotation}, end; 
						iter != end;
						++iter
					) {
						std::cout << "@" << iter->position() 
							<<  ", [" << iter->length() << "] => " << iter->str() << std::endl;  
					}
					
					return 0;
				}
				
			* Örnek 6,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						administration => administ(ra){tion}
						attention => at(te)n{tion}
						collection => (co)llec{tion}
						condition => (co)ndi{tion}
						direction => di(re)c{tion}
						education => edu(ca){tion}
						generation => gene(ra){tion}
						institution => ins(ti)tu{tion}
						international => in(te)rna{tion}al
						operation => ope(ra){tion}
						population => (po)pula{tion}
						position => po(si){tion}
						production => p(ro)duc{tion}
						relationship => (re)la{tion}ship
						section => (se)c{tion}
						situation => (si)tua{tion}
						station => s(ta){tion}
						traditional => t(ra)di{tion}al
					*/

					auto sVec{ get_dictionary("wordList.txt") };
					std::regex rgx{ ".*([ckprts]+[aeio]+).*([tcln]ion).*" };
					
					std::smatch matchResults;
					for(auto& word : sVec)
					{
						if( std::regex_match(word, matchResults, rgx) )
						{
							std::cout << word << " => ";
							word.insert( matchResults.position(1), 1, '(' );
							word.insert( matchResults.position(1) + matchResults.length(1) + 1, 1, ')' );
							word.insert( word.begin() + matchResults.position(2) + 2, '{' );

							word.insert( word.begin() + matchResults.position(2) + 3 + matchResults.length(2), '}' );
							
                            std::cout << word << std::endl;
						}
					}
					
					return 0;
				}
				
			* Örnek 7,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						administration
						attention
						collection
						condition
						direction
						education
						generation
						institution
						international
						operation
						population
						position
						production
						relationship
						section
						situation
						station
						traditional
					*/

					auto sVec{ get_str_from_file("wordList.txt") };
					std::regex regexNotation{ ".*([ckprts]+[aeio]+).*([tcln]ion).*" };
					
					for_each(
								std::sregex_iterator{sVec.cbegin(), sVec.cend(), regexNotation},
								std::sregex_iterator{},
								[](const auto& matchResults){ std::cout << matchResults.str() << std::endl; }
							);
					
					return 0;
				}
				
		>>> 'regex' notasyonu ile 'tokenizing' işlemleri: 
			* Örnek 1,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						Uyanlarin tamami: 
						[projede,]
						[projeyi]
						[profesyonel]
						[programcilar]
						
						
						
						Birinci sub-match grubu: 
						[pro]
						[pro]
						[pro]
						[pro]
						
						
						
						Ikinci sub-match grubu: 
						[jede,]
						[jeyi]
						[fesyonel]
						[gramcilar]
						
						
						
						Birinci ve ikinci sub-match grubu: 
						[pro]
						[jede,]
						[pro]
						[jeyi]
						[pro]
						[fesyonel]
						[pro]
						[gramcilar]
						
						
						
						Butun gruplar: 
						[projede,]
						[pro]
						[jede,]
						[projeyi]
						[pro]
						[jeyi]
						[profesyonel]
						[pro]
						[fesyonel]
						[programcilar]
						[pro]
						[gramcilar]
						
						
						
						Ayiraclar: 
						[]
						[ ]
						[ basariya ulastıracak, ]
						[ ]
						[ gerekiyor]
						
						

					*/

					std::string textToSearchIn{ 
						"projede, projeyi basariya ulastıracak, profesyonel programcilar gerekiyor" 
					};

					std::regex regexNotation{ "\\b(pro)([^ ]*)" };
					// 'pro' kelimesi, kelimenin başında olacak.
					// Devamında ise, boşluk karakteri olmayan karakterlerden 'n' kadar olacak. 
					
					std::sregex_token_iterator regexTokenizer;
					
					// '0' geçmemiz gerekiyor, uyanlar için.
					std::cout << "Uyanlarin tamami: \n";
					
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, 0); 
						iter != regexTokenizer; ++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					
					// '1' geçmemiz gerekiyor. Bir numaralı 'sub-match', 'pro' kelimesidir.
					std::cout << "Birinci sub-match grubu: " << std::endl;
					
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, 1); 
						iter != regexTokenizer; 
						++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					
					// '2' geçmemiz gerekiyor. İki numaralı 'sub-match', boşluk karakteri olmayan bütün karakterlerdir.
					std::cout << "Ikinci sub-match grubu: " << std::endl;
					
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, 2); 
						iter != regexTokenizer; 
						++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					
					// 'std::initializer_list' kullanarak '1' ve '2' geçildi. Her iki 'sub-match' grubu.
					std::cout << "Birinci ve ikinci sub-match grubu: " << std::endl;
					
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, {1,2});
						iter != regexTokenizer;
						++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					
					std::cout << "Butun gruplar: " << std::endl; // 'std::initializer_list' kullandık.
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, {0,1,2});
						iter != regexTokenizer;
						++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					
					std::cout << "Ayiraclar: " << std::endl;
					for(
						std::sregex_token_iterator iter(textToSearchIn.begin(), textToSearchIn.end(), regexNotation, -1); 
						iter != regexTokenizer; 
						++iter
					) {
						std::cout << "[" << *iter << "]" << std::endl;
					}
					
					std::cout << "\n\n" << std::endl;
					return 0;
				}
				
			* Örnek 2,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						murat
						kadir
						kemal
						ve
						aysenur
						Cpp
						ogrendiler
						iyi
						yaptilar
					*/
					
					std::string textsToSearchIn{ "murat, kadir, kemal ve aysenur Cpp ogrendiler, iyi yaptilar..."  };
					
					// Boşluk karakteri, virgül karakteri ve nokta karakterinden bir yada daha fazla olabilir.
					std::regex regexNotation{ "[\\s,.]+" };
					
					// '-1' geçerek bir nevi kurala uymayanları temin ettik.
					std::sregex_token_iterator iter{ textsToSearchIn.cbegin(), textsToSearchIn.cend(), regexNotation, -1 };
					
					std::sregex_token_iterator end;
					
					for(; iter != end; ++iter)
						std::cout << iter->str() << std::endl;
						
					return 0;
				}
				
		>>> 'regex' notasyonu ile 'replace' işlemleri: 
			* Örnek 1,
				//..
				int main() 
				{
					std::string str{ "profesyonel butun programcilar projelerdeki tum yazilimsal problemleri cozebilmeli." };
					std::regex rgx{ "\\b(pro)([^ ]*)" };
					
					// '$1' yerine birinci 'sub-match', '$2' yerine ise ikinci 'sub-match' grubu gelecektir.
					auto s{ std::regex_replace(str, rgx, "($1)($2)") };
					
					// OUTPUT => (pro)(fesyonel) butun (pro)(gramcilar) (pro)(jelerdeki) tum yazilimsal
					// (pro)(blemleri) cozebilmeli.
					std::cout << s << std::endl;
					
					auto ss{ std::regex_replace(str, rgx, "$1_$2 ") };
					
					// OUTPUT => pro_fesyonel  butun pro_gramcilar  pro_jelerdeki  tum yazilimsal pro_blemleri  cozebilmeli.
					std::cout << ss << std::endl;
					
					auto sss{ std::regex_replace(str, rgx, "$&") };
					
					// OUTPUT => profesyonel butun programcilar projelerdeki tum yazilimsal problemleri cozebilmeli.
					std::cout << sss << std::endl;
					
					auto ssss{ std::regex_replace(str, rgx, "($&) [$&]") };
					
					// OUTPUT => (profesyonel) [profesyonel] butun (programcilar) [programcilar] (projelerdeki)
					// [projelerdeki] tum yazilimsal (problemleri) [problemleri] cozebilmeli.
					std::cout << ssss << std::endl;
					
					return 0;
				}
				
			* Örnek 2,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						[corona virus yayiliyor,
						olu sayisinin artmasindan
						endise edilmekte.
						Allah ulkemizi korusun
						Amin!]
						[corona virus yayiliyor, olu sayisinin artmasindan endise edilmekte. Allah ulkemizi korusun Amin!]
					*/
					
					std::string str{ 
						"corona virus yayiliyor,\n"
						"olu sayisinin artmasindan\r\n"
						"endise edilmekte.\n"
						"Allah ulkemizi korusun\r\n"
						"Amin!"
					};
					
					std::cout << "[" << str << "]" << std::endl;
					
					std::regex rgx{ "\\r?\\n" };
					
					auto line{ std::regex_replace(str, rgx, " ") };
					
					std::cout << "[" << line << "]" << std::endl;
					
					return 0;
				}
				
			* Örnek 3,
				//..
				int main() 
				{
					/*
						# OUTPUT #
					*/
					
					std::string str{ "profesyonel butun programcilar projelerdeki tum yazilimsal problemleri cozebilmeli." };
					std::regex rgx{ "\\b(pro)([^ ]*)" };
					
					auto s{ std::regex_replace(str, rgx, "($1)($2)", std::regex_constants::format_first_only) };
					
					// OUTPUT => (pro)(fesyonel) butun programcilar projelerdeki tum yazilimsal problemleri cozebilmeli.
					std::cout << s << std::endl;
					
					return 0;
				}
				
			* Örnek 4,
				//..
				int main() 
				{
					/*
						# OUTPUT #
						Bir yazi giriniz: 
						damla damla damlıyordu akan yağmur damlaları
						damla damlıyordu akan yağmur damlaları
					*/
					
					std::string str;
					
					std::cout << "Bir yazi giriniz: " << std::endl; std::getline(std::cin, str);
					
					std::regex rgx{ R"(\b(\w+)\s+\1)" };
					
					std::cout << std::regex_replace(str, rgx, "$1") << std::endl;
					
					return 0;
				}

    Şimdi de aşağıya iki adet pekiştirici örnek bırakıyoruz:
        * Örnek 1,
            //..
            int main() 
            {
                /*
                    # OUTPUT #
                    Regex Notation : [-+]?[\d]*\.?[\d]+
                    -------------------------------------------------------
                    2.86356 => VALID
                    +123.78965 => VALID
                    -7862.8273 => VALID
                    .7 => VALID
                    *5 => INVALID
                    .7123 => VALID
                    18763.8263 => VALID
                    -0.734 => VALID
                    254.abc => INVALID
                    enes => INVALID
                    12.87e-5 => INVALID
                */
                
                std::ifstream ifs{ "float.txt" };
                if(!ifs)
                    return 1;
                    
                // 'raw-string literal' kullanmadığımız için elimizdeki yazıyı uygun bir 'regex' notasyonu haline
                // getirdik.
                std::string regexString{ "[-+]?[\\d]*\\.?[\\d]+" };
                std::cout << "Regex Notation : " 
                    << regexString << "\n-------------------------------------------------------\n";
                
                std::regex regexNotation{ regexString };
                
                std::string lines;
                while( ifs >> lines )
                {
                    if( std::regex_match(lines, regexNotation) )
                    {
                        std::cout << lines << " => VALID" << std::endl;
                    }
                    else
                    {
                        std::cout << lines << " => INVALID" << std::endl;
                    }
                }
                
                return 0;
            }
            
        * Örnek 2, https://regex101.com
            //..
            constexpr const char* eRegex()
            {
                return R"((?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\
                x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+
                [a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]
                |[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-
                \x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\]))";
            }
            
            int main() 
            {
                /*
                    # OUTPUT #
                    Regex Notation : /(?:[a-z0-9!#$%&'*+\=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\=?^_`{|}~-]+)*|"(?:[\x01-\x08
                    \x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9
                    -]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-
                    9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c
                    \x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/gm
                    E-mail address : ali.ali.@gmail.co
                    [Aali.ali.@gmail.co] is INVALID...
                */
                
                /*
                    # OUTPUT #
                    Regex Notation : (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08
                    \x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-
                    9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?
                    [0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b
                    \x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
                    E-mail address : aali.ali.@gmail.com
                    [aali.ali.@gmail.com] is INVALID...
                */
                
                /*
                    # OUTPUT #
                    Regex Notation : (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08
                    \x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
                    E-mail address : aali.ali@gmail.com
                    [aali.ali@gmail.com] is VALID...
                */
                
                /*
                    # OUTPUT #
                    Regex Notation : (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08
                    \x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-
                    9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]
                    ?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08
                    \x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
                    E-mail address : ahmet.pehlivanli@yahoo.com
                    [ahmet.pehlivanli@yahoo.com] is VALID...
                */

                auto regexNotation{ eRegex() };
                std::cout << "Regex Notation : " << regexNotation << std::endl;
                
                std::regex rgx{ regexNotation };
                
                std::string eMail;
                std::cout << "E-mail address : "; std::cin >> eMail;
                
                if( std::regex_match(eMail, rgx) )
                {
                    std::cout << "[" << eMail << "] is VALID..." << std::endl;
                }
                else
                {
                    std::cout << "[" << eMail << "] is INVALID..." << std::endl;
                }
                return 0;
            }