> 'complete-type' ve 'incomplete-type' : Derleyicinin sadece bildirim ile karşılaştığı, tanımı ile karşılaşmadığı durumlar
'incomplete-type' olarak geçer. Eğer tanımı ile karşılaşırsa 'complete-type'. Peki bizler bu türler ile neler yapabilir,
neler yapamayız?:
	>> 'incomplete-type' ile,
		>>> Fonksiyon bildirimlerinde geri dönüş değer türü ve/veya parametre değer türü olarak kullanabiliriz.
			* Örnek 1,
				//..
				class Cenk; // incomplete-type, forward-decleration
				class Neco; // incomplete-type
				
				Cenk f1(Neco other); 
				Cenk* f2(Neco* other);
				Cenk& f3(Neco& other);
				
		>>> Tür eş isim bildirimi yapabiliriz.
			* Örnek 1,
				//..
				class Cenk; // incomplete-type
				
				typedef Cenk* CenkPtr;
				using CenkRef = Cenk&;
				
		>>> 'gösterici' ve 'referans' tanımlamalarında kullanılabilirler. Çünkü 'gösterici' ler, gösterdiği objeden bağımsız
		olarak, bellekte aynı boyutta yer kaplarlar. Yani 'Neco' sınıfından bir değişkenin adresini tutacak 'gösterici' ile
		'char' türden bir değişkenin adresini tutacak 'gösterici' aynı boyutta yer kaplar. Fakat 'function-pointer' ile aynı
		boyutta yer kaplayacağına dair bir garanti YOKTUR. Ama 'function-pointer' lar da kendi içinde aynı boyutta yer
		kaplayacağı garanti altında.
			* Örnek 1,
				class Cenk; // incomplete-type
				
				class Memo foo(class Dedo* other); // Fonksiyon bildirimi.
				
				int main()
				{
					Cenk* ptr = nullptr;
					
					class Ahmo* ptrAhmo = nullptr;
					// 'Ahmo' sınıf türü için 'forward-decleration' yazmadığımız için, 'class/struct' anahtar sözcüğü ile
					// birlikte yazmamız gerekiyor. Bu durum fonksiyon bildirimlerinde de geçerli.
												   
					// Fakat bu 'göstericileri' DEREFENCE EDEMEYİZ, SENTAKS HATASIDIR.
				}
				
			* Örnek 2,
				//..
				
				class Neco; // forward-decleration
				
				Neco* foo(); // Legal
				Neco& func(); // Legal
				
				int main()
				{
					Neco* p1 = foo(); // Legal
					Neco& r1 = func(); // Also legal.
				}
				
		>>> 'inheritence' mekanizmasında kullanılamaz. Mutlak suret kalıtımın yapıldığı yerde tanımı olması gerekiyor.
			* Örnek 1,
				class Aksu;
				
				class Mehmet : public Aksu { }; // Sentaks hatası. 'incomplete type' is not allowed.
				
		>>> 'extern' bildirimlerinde kullanılabilir.
			* Örnek 1,
				class Furkan;
				
				extern Furkan f;
				// İşte 'extern decleration' kısmı burasıdır. Bunun tanımı başka bir modülde yapılıyor. Legaldir.
				
				extern Furkan a[]; // Legaldir.
				
		>>> Sınıf tanımları içerisindeki 'static' 'data-member' bildirimlerinde kullanılabilir.
			* Örnek 1,
				//..
				
				class A; // forward-decleration
				
				class Myclass{
					static A ax; // Legal.
				};
				
		>>> 'incomplete-type' TÜRLER İLE NESNE OLUŞTURAMAYIZ.
			* Örnek 1,
				//..
				
				class A;
				class B;
				class C;
				
				class Myclass{
					A ax; // Sentaks hatası.
					B bx; // Sentaks hatası.
				};
				
				int main()
				{
					C cx; // Sentaks hatası.
				}
				
				// Yukarıdaki sentaks hatasını gidermek için iki yöntemimiz var:
				// i. İlgili sınıfların tanımlarının olduğu başlık dosyalarını '#include' etmek
				// ii. 'pimpl' deyimini kullanmak, ki böylelikle sınıfımızın 'private' bölümünü sınıf tanımından
				// çıkartmış oluyoruz. 
				
		>>> 'sizeof()' OPERATÖRÜNÜN OPERANDI YAPAMAYIZ. SENTAKS HATASIDIR (AYNI ZAMANDA 'void' TÜRÜ DE YAPILAMAZ ÇÜNKÜ O DA
		BİR 'incomplete-type').
		
	>> 'incomplete-type' kullanarak çözeceğimiz problemleri, BAŞLIK DOSYASI EKLEYEREK ÇÖZMEKTEN KAÇINMALIYIZ.
