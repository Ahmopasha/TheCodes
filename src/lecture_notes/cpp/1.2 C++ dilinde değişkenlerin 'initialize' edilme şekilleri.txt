> C++ dilinde değişkenlerin 'initialize' edilme şekilleri:
	>> 'statik' ömürlü bir değişken hayata gelirken 'value-initialize' edilmemiş ise 'zero-initialize' edilirler.
		>>> 'zero-initialize' : Değişkenimiz aritmetik türden ise '0' değerini, 'boolean' türden ise 'false' değerini ve
		'pointer' tip ise 'nullptr' değerini alırlar. Dizilerin bildirilmesinde de aynı durum geçerlidir; bütün öğeleri
		yukarıdaki şekliyle hayata gelirler.
	
	>> 'automatic' ömürlü bir değişken hayata gelirken 'value-initialize' edilmemiş ise 'default-initialize' edilirler.
		>>> 'default-initialize' : Değişkenler 'garbage-value' tutarlar. Tuttukları bu değerleri değiştirmeden kullanmak ise
		'Tanımsız Davranışa' neden olur. Bu şekilde hayata gelen değişkenlerimizi de tam olarak kullanılacakları yerlerde
		bildirmeliyiz ki 'scope leakage' a neden olmasın, gereksiz isim kalabalığı oluşturmasın. Aşağıdaki örneği inceleyin,
			* Örnek 1,
				// Some codes here...
				int main()
				{
					int x;
					// 'x' isimli değişken 'garbage-value' değer tutmaktadır. Çünkü 'default-initialize' edilmiştir.
					
					int y = x;
					// 'x' isimli değişkenin değerini değiştirmeden kullandığımız için bu satır 'Tanımsız Davranış'a
					// sebebiyet vermektedir.
				}
	
	>> C++ dilinde olan ama C dilinde olmayan 'direct-initialize' ve 'brace-initialize veya uniform-initialize' açıklamaları
	için aşağıdaki örneği inceleyin,
		* Örnek 1,
			// Some Code here...
			
			int main()
			{
				int x(100);
				// C++ dilindeki 'direct-initialize' şekli.
				
				int y();
				// Artık burada bir fonksiyon bildirimi söz konusudur. İsmi 'y', geri dönüş değeri 'int' türden ve parametre
				// almayan bir fonksiyon.
				
				int z{200};
				// C++11 ile dile eklenen 'brace-initialize veya uniform-initialize' şekli. Yukarıdaki gibi
				// 'brace-initialize' şekli kullanıldığında, 'narrowing conversion' sentaks hatasına neden olur. Harici
				// olarak bizlerin 'casting' yapması gerekiyor. Fakat 'narrowing conversion', diğer 'initialize' şekillerinde
				// sentaks hatasına neden olmaz. Sadece, veri kaybına neden olabilir.

				// Eğer eşitliğin sol tarafındaki (işaretli) tür, sağ tarafındaki değeri taşıyamayacaksa, taşma meydana gelir
				// ve 'Tanımsız Davranış'a neden olur. İşaretsiz türlerde ise taşma; rakam, bitlerin taşıyabileceği maksimum
				// sayıya bölünür. Geriye kalan sayı, taşma sonucunda elde edilendir.
				
				int q{};
				// Eleman hayata '0' değeri ile gelmiş olur. C++ dilinde geçerlidir, C dilinde böyle bir kullanım yoktur.
				
				int t[200]{};    
				// C++ dilinde legal ve bütün elemanları 'zero-initialize' eder.
				
				int tt[200] = {}; 
				// C dilinde bu sentaks hatası. Çünkü en az bir elemanı olmak zorunda. C++ dilinde legal ve bütün elemanları
				// 'zero-initialize' eder.
			}
			
		* Örnek 2,
			// Some codes here...
			class A{};
			
			class B{
				public:
					B(A);
			};
			
			int main()
			{
				B bx(A());
				// Bu deyim derleyici tarafından iki farklı şekilde yorumlanabilir. Bunlardan birincisi; bu çağrı, geri dönüş
				// değeri 'B' türünden, fonksiyon parametresi 'A' türünden 'function-pointer' ve ismi 'bx' olan bir
				// fonksiyonun bildirimi şeklinde. Bunlardan ikincisi; bu çağrı, 'B' türünden ve ismi 'bx' olan bir nesneye,
				// 'A' türünden 'geçici-nesne' ile ilk değer veriyorum. Bu durumda derleyici, 'fonksiyon bildirimi' şeklinde
				// yorumlayacaktır bu deyimi. 'Most Vexing Parse' işte bu durumu anlatmaktadır.
				
				B cx{ A() };
				// Artık 'Most Vexing Parse' durumu da ortadan kalkmış oluyor. Bu çağrı, yukarıdaki senaryodaki ikinci anlama
				// gelmektedir. Yani; bu çağrı, 'B' türünden ve ismi 'bx' olan bir nesneye, 'A' türünden 'geçici-nesne' ile
				// ilk değer veriyor.
			}