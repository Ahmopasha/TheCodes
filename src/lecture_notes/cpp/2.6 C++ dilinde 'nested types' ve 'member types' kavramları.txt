> 'Nested Types / Member Types' :  Bir türün tanımının 'class scope' içerisinde yapılması durumudur.
    * Örnek 1,
        //..
        class Data{};
        
        class Myclass{};
        
        // Yukarıdaki 'Data' ve 'Myclass' sınıfları aynı isim alanı içerisinde tanımlanmışlardır.
        
        int main()
        {
            Data mx; // Legal
            Myclass my; // Legal
        }
    
    * Örnek 2,
        class Myclass{ // enclosing class
            class Data{ // nested class
                
            };
        };
        
        // Yukarıdaki 'Data' sınıfı, 'Myclass' içerisinde tanımlanmıştır.
        
        int main()
        {
            Data mx;
            // Sentaks hatası çünkü 'Data' sınıfının tanımı 'Myclass' içerisinde yapıldığından, ilgili ismi 'class scope'
            // içerisinde aratmamız gerekiyor.
            
            Myclass::Data my;
            // Artık legal. Fakat 'access control' e takılacağından dolayı SENTAKS HATASI.
        }
    
    >> 'class scope' içerisinde tanımlandığından, 'access control' e de tabiidir.
    >> 'Nested Types' olarak illa da 'class-type' olması gerekmiyor. Aşağıdakiler de 'Nested Types' için örnek olarak
    verilebilir.
        >>> 'class', 'union' vs.
        >>> 'typedef' bildirimleri / 'using' bildirimleri.
            * Örnek 1,
                //..
                class Myclass{
                    typedef int Word;
                    using Word = int;
                    // Artık 'Word', 'class scope' içerisinde tanımlandığından, ilgili sınıf ismi ile nitelemeliyiz.
                };
        
        >>> Numaralandırma sınıflarından olabilir('enum class'). 
    
    >> İsim arama, sınıfın bildiriminin başladığı yerden başlar ve ilk kullanıldığı yerde sona erer. Eğer bulunamaz ise
    'namespace scope' içerisinde aranır.
        * Örnek 1,
            //..
            
            // (iii) Eğer sınıf içerisinde belirtilen alanda bulunamaz ise artık isim burada aranmaya başlayacak, tıpkı
            // C dilinde olduğu gibi. Yani sayfanın en üst noktasından başlayıp, sınıf bildiriminin olduğu yere kadarki
            // alanda.
            class Myclass
            {
                //(ii) İsim aramanın ilk noktası da burası. Yani sınıf bildiriminin başladığı yer.
                Word wx; // (i) 'Word' ismi ilk burada görüldüğü için isim aramanın son noktası burası.
                typedef int Word;
            };

        * Örnek 2,
            //..
            
            struct Word{};
            
            class Data{
                // İsim arama kuralları sonucunda ilgili ismin bir sınıf ismi olduğu, 'int' türünün EŞ İSMİ OLMADIĞI
                // anlaşıldı.
                Word wx;
                
                typedef int Word;
            };
        
        >>> 'inline' olarak tanımlanan 'member function' içerisindeki isim arama kuralları hala geçerli. Yani önce
        ilgili fonksiyon bloğunda aranır. Bulunamaz ise 'class scope' İÇERİSİNDE HER YERE BAKILIR. Bulunamazsa
        'namespace scope' içerisinde aranır. Dolayısıyla bu kural 'nested-types' için de geçerlidir. 
            * Örnek 1,
                //..
                class Myclass{
                    void func()
                    {
                        Nested nx;
                        // İlgili 'Nested' ismi sınıf bloğu içerisinde bulunamadığından, sınıf içerisindeki
                        // her yere BAKILIR.
                    }
                    
                    class Nested{};
                };

    >> Bir sınıfın 'Nested-type' ı olduğu gibi, o 'nested-type' türünden 'static' ve/veya 'non-static' VERİ ELEMANLARINA
    DA SAHİP OLABİLİR. BU İKİSİ FARKLI NOKTALARDIR.
        * Örnek 1,
            //..
            class Myclass{
                class Data{};
                
                Data dx;
            };
        
    >> Bir sınıf 'interface' olarak yine bu 'nested-type' türleri kullanabilir.
        * Örnek 1,
            //..
            class Myclass{
                public:
                    class Data{};
                    
                    Data foo();
                    
                    void func(Data);
            };
            
            int main()
            {
                Myclass mx;
                
                auto x = mx.foo();
                // Myclass::Data x = mx.foo();
                
                mx.func(x);
            }
        
    >> STL içerisindeki 'iteratör' sınıfı, 'nested-types' için güzel bir örnektir.
        * Örnek 1, Temsili gösterimi
            //..
            template<...>
            class Vector{
                public:
                    class iterator{
                        
                    };
                    
                    iterator begin();
                    iterator end();
                    
                    //..
            };
            
        * Örnek 2, Temsili kullanımı
            //..
            
            int main()
            {
                std::vector<int> ivec;
                
                std::vector<int>::iterator iter = ivec.begin();
                // auto iter = ivec.begin();
            }
            
    >> 'enclosing-type' olan sınıf, 'nested-type' olan sınıfın 'private' bölümüne erişebilir mi? El-cevap: ERİŞME HAKKI
    YOKTUR.
        * Örnek 1,
            //..
            class Nec{
                class Nested{
                    void nfoo();
                };
                
                void necFoo()
                {
                    Nested myNested;
                    myNested.nfoo();
                    // 'private' KISMA ERİŞİM HAKKI OLMADIĞINDAN SENTAKS HATASIDIR.
                    // error: ‘void Nec::Nested::nfoo()’ is private within this context
                }
            };

            int main()
            {
                Nec mx;
                
                mx.necFoo();
            }
        
    >> Eğer 'nested-type' friend özelliği verirse 'enclosing-type' a, o zaman erişebilir.
        * Örnek 1,
            //..
            class Nec{
                class Nested{
                    friend class Nec; // 'Nec' sınıfı artık 'Nested' sınıfının 'private' kısmına erişebilir.
                    void nfoo(){}
                };
                
                void necFoo()
                {
                    Nested myNested;
                    myNested.nfoo();
                                    
                }
            };

            int main()
            {
                Nec mx;
                
                mx.necFoo(); // error: ‘void Nec::necFoo()’ is private within this context
            }
            
    >> 'nested-type', 'enclosing-type' olan sınıfın 'private' kısmına erişebilir (since C++11).
        * Örnek 1,
            //..
            class Nec{
                static void f();
                int mx;
                
                class Nested{
                    void nfoo()
                    {
                        Nec::f(); // LEGAL.
                        
                        auto sz = sizeof(mx); // LEGAL.
                    }
                };
            };
        
    >> İlginç bir kural:
        * Örnek 1,
            //..
            class Nec{
                private:
                    class nested{
                        
                    };
                    
                public:
                    nested func();
            };
            
            int main()
            {
                Nec myNec;
                
                Nec::nested x = myNec.func();
                // Bu ilk değer verme sentaks hatası çünkü 'nested' sınıfı kapsayan sınıfın 'private' bölümünde.
                
                auto xx = myNec.func(); // LEGAL since C++11. 
            }
        
    >> 'nested-type' sınıflara ait üye fonksiyonların tanımlanmaları:
        >>> 'inline' olarak tanımlayabiliriz. Yani sınıf tanımının içerisinde yaparak.
            * Örnek 1,
                //..
                class Neco{
                    class Nested{
                        void func()
                        {
                            //..
                        }
                    };
                };
            
        >>> Başka yerde tanımlıyorsak da ilgili fonksiyonun ismini hem kapsayan sınıf ile hem de içerideki sınıf ile
        nitelemeliyiz.
            * Örnek 1,
                    //..
                    class Neco{
                        class Nested{
                            void func();
                            
                            Nested foo(Nested other);
                        };
                    };
                    
                    void Neco::Nested::func()
                    {
                        //..
                    }
                    
                    Neco::Nested Neco::Nested::foo(Nested other)
                    {
                        Nested myNested = other;
                        
                        return myNested;
                    }
                    
                    // Yukarıdaki kullanımda ilgili fonksiyonun tanımındaki ve bildirimindeki parametre parantezinin
                    // içerisindeki isimler 'class-scope' da olduğundan, 'Neco' ile nitelememize gerek yoktur. Aynı
                    // şekilde ilgili fonksiyonun bloğu da 'class-scope' içerisinde olduğundan, 'Neco' ile nitelemeye
                    // gerek yoktur. Fakat fonksiyonun geri dönüş değerinin türünü yazarken 'Neco' nitelemesini YAPMAK
                    // ZORUNDAYIZ. Çünkü o kısım 'class-scope' içerisinde DEĞİL, 'namespace-scope' içerisinde.
            
    >> 'namespace scope' içerisinde yapılan 'incomplete-type' bildirimleri ile neler yapabiliyorsak, 'enclosing-type'
    sınıf içerisinde yapılan 'nested-type' sınıf bildirimleri ile aynı şeyleri yapabiliriz.
        * Örnek 1,
            //..
            class Neco{
                class Nested; // 'forward-decleration' of class Neco
                
                Nested* ptr; // LEGAL
                Nested foo(); // LEGAL
            };
