> C++ dilinde Numaralandırma Türleri(enum) ve Kapsamlandırılmış Numaralandırma Türleri(enum class): 
	>> Gerek C dilinde, gerek C++ dilinde 'enum' türleri hem 'user-defined types' hem de 'integer types' olarak geçmektedir. 
	
	>> C dilinde, 'enum' larda kullanılan 'underlying type', 'int' olmak zorunda. Yani kabaca, 'sizeof(int) == sizeof(enum)'
	diyebiliriz. Fakat C++ dilinde bu durum farklı. 'enum' türünün elemanlarına atanan değere bakarak derleyici,
	'underlying type' ı seçiyor. Eğer elemanlara atanan değerlerden çıkarım yapılan türler arasında farklılık var ise
	'underlying type' seçimi daha kapsamlı türe göre yapılıyor. Bunun açtığı sorunlardan birisi de 'forward declaration'
	sırasında. Derleyici, 'enum' türünün tanımını görmediğinden ve eğer bu türden bir nesnenin bildirildiğini görürse,
	SENTAKS HATASI verecektir.
	
	>> Diğer 'aritmetik' türlerden 'enum' türlere dönüşüm SENTAKS HATASI fakat 'enum' türlerden 'aritmetik' türlere,
	'underlying type' a bakılmaksızın, otomatik dönüşüm vardır.
		* Örnek 1,
			// Some code here...
			enum Color{
				White,
				Gray
			};
			
			int main()
			{
				Color mycolor = Gray;
				
				mycolor = 5;
				// Bu çağrı bir sentaks hatasıdır. Eşitliğin sağ tarafında ya bir numaralandırma sabiti ('Gray') ya da
				// 'Color' türünden bir başka nesne gelmeli.
				
				long ival = mycolor; // Bu çağrı ise LEGAL bir çağrıdır.
			}
			
	>> 'enum' içerisindeki numaralandırma sabitlerinin ('enumaration constant') ayrı bir kapsamları yoktur. Eğer
	'global namespace' de bildirilen bir 'enum' içerisindeki sabitler, kaynak dosyanın her tarafında görülür durumdadırlar.
	Eğer farklı başlık dosyalarından gelen 'enum' türlerin numaralandırma sabitlerinin ismi aynı ise bu durum SENTAKS
	hatasına yol açacak.
		* Örnek 1,
			#include "screen.h"
			#include "traffic.h"
			
			enum ScreenColor
			{
				White,
				Green,
				Red
			};
			
			enum TrafficLight
			{
				Red,
				Yellow,
				Green
			};
			
			// Bu noktada, yukarıdaki numaralandırma sabitleri görülür durumdadırlar. Fakat 'Green' iki farklı 'enum'
			// içerisinde olmasına rağmen, yani birbirinden farklı kaynaklara hitap etmesine rağmen derleyici açısından
			// 'redefinition' durumu olacak. Bu durum da SENTAKS HATASINA yol açacak.
			
	>> C++11 ile yukarıdaki üç soruna çözüm bulmak için 'enum class' türler eklendi. Fakat 'class' isminin geçmesi, bu türü
	bir 'class-type' yapmaz. Sadece farklı bir 'enum' türü. Artık bu tür ile 'underlying type' ı biz seçebiliyoruz. Bundan
	dolayıdır ki 'forward declaration' yaptıktan sonra 'underlying type' ı da belirtebileceğimiz için, bu türden bir nesnenin
	bildirimini yapabiliriz. Ayrıca 'enum class' türünden 'aritmetik' türlere otomatik dönüşüm artık SENTAKS HATASIDIR.
	'static_cast<>' operatörü ile harici olarak dönüşüm yaptırabiliriz. Son olarak 'enum class' içerisinde bulunan
	numaralandırma sabitlerinin kendi türleri vardır. Artık bu sabitleri kullanırken, ait olduğu 'enum class' türünü
	nitelememiz gerekiyor.
		* Örnek 1,
			// Some code here...
			
			// 'underlying type' is 'unsigned int'.
			enum class Color : unsigned int 
			{
				White,
				Gray
			};
			
			int main()
			{
				Color mycolor = Color::Gray;
				// 'Gray' numaralandırma sabitinin 'Color' enum türüne ait olduğunu nitelememiz gerekiyor.
				
				long ival = mycolor; // Artık SENTAKS HATASI.
			}